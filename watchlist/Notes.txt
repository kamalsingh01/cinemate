     
CLASS BASED VIEWS: 

REST framework provides an APIView class, which subclasses Django's View class. It is different from view class in Django as: 

1. Requests passed to the handler methods will be REST framework's Request instances, not Django's HttpRequest instances.
2. Handler methods may return REST framework's Response, instead of Django's HttpResponse. The view will manage content negotiation and setting the correct renderer on the response.
3. Any APIException exceptions will be caught and mediated into appropriate responses.
4. Incoming requests will be authenticated and appropriate permission and/or throttle checks will be run before dispatching the request to the handler method, meaning authentication and permissions are checked before making call to handler methods.
 

 5. We create view class and extend API view. inside, Instead of defining condition for checking the request method, we can directly use Httprequest based methods provided by API View class
> We do not need to define any decorator with our class based views.

VALIDATIONS: 

> Validations are defined in Serializers and are called in views.

    Types: 
    1. Field Level Validation : Use to validate any particular field. We define a method in serializer as validate_<field_name> and then define the conditions to check.
    2. Object level validation : Valiates data object of any class, for e.g. comparing two fields of any object.
    3. validator() : used/applied specifucally on the field instance on a serializer class.(in lamen, applied at run time.) - saerializer.py, line 7

SERIALIZER FIELDS: 
     
>. Serializer fields handle converting between primitive values and internal datatypes. They also deal with validating input values, as well as retrieving and setting the values from their parent objects.
>  The serializer fields are declared in fields.py, but are imoported from reset_frmeork.serializers
> different fields : BooleanField, CharField, EmailField, SlugField, URLField, ImageField,DateTimeField, ChoiceField , etc...

CORE ARGUMENTS : Core arguments helps applying some constraints and resrtiction on the field and its working.
            for e.g : read_only, write_only, required, default, validators, etc...

MODEL SERIALIZER : 

> The ModelSerializer class provides a shortcut that lets you automatically create a Serializer class with fields that correspond to the Model fields. Pretty much similar to Serializers class but: 

    >>. includes simple default implementations of .create() and .update().
    >>. Model serializer automatically generate a set of fields based on the corresponding model.
    >>. automatically generates validators for the serializer, like unique_together validators
   

> By default, all the model fields on the class will be mapped to a corresponding serializer fields.
> In ModelSerializer class we define meta class which defines the correspondin model and fields are to be serialized from the model.
> If we want all the fields, fields = "__all__" 
> if we want some fields, fields = [ "id", "title", "description" ]

HYPERLINK MODEL SERIALIZER :
> Similar to ModelSerializer class except that it uses hyperlinks to represetns relationaships, rather than primary key


GENERIC API VIEWS : 

MIxins: derived from Generic API View, generally used to perform straight forward CRUD Operations

CONCRETE API VIEWS CLASSES : When we use Concrete view classes, there is no need to define any methods to perform CRUD operations, methods are already defined in the class definition. In concrete view classes we just import task specific view classes.

VIEWSETS:  Using viewset we combine two different classes for list and retrive and under on class we define two multiple functions and these functions are referred with using routers. 
Routers combine all different types of links/urls
This helps shortening the number of URLs and used in big projects.

MODEL VIEWSETS : Model viewset by default provides all the CRUD methods and we can use all of these just under one class.

PERMISSIONS: 
> Permissions are used to grant or deny access for different classes of users to different parts of the API. Permissions manly runs at the front of any view class code.

> The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in REST framework.

> Permissions in REST framework are defined as list of permission classes and before running the view class code, this list of permissions are checked. If failed, exceptions.PermissionDenied or exception.NotAuthnticated exception will be raised and main body of the view will not run.( code 403 or 401 can be returned)
    403 Forbidden - request authenticated but permission denied

> Oject level permission is also used in drf, where it determines if an user is allowed to act on an object or not.
Permissions are applied in two ways, either by defining it in SETTINGS.py which affects all the view class. And, second is Oject level permission, where we define the permission in view class itself, and restrict it for certain URL or view.
    multiple permissions: allowany, IsAuthenticated(user must be logged-in), ISAdminUser, IsAuthenticatedOrReadOnly( logged in user can edit, otherwise others can read only), 

> The default permission policy may be set globally, using the DEFAULT_PERMISSION_CLASSES setting.( in settings.py file) at bottom.

> We can set the authentication policy on a per-view, or per-viewset basis, using the APIView class-based views.(Object Level Permissions)

@ CUSTOM BASED PERMISSIONS : Used for any special requirement which allows us to set permissions based on whether the user is authenticated or not, the request method, the group that the user belongs to, object attributes, the IP address... or any of their combinations.

> to implemnt first we need to store our code for Custom permission and then to import it in the view classes, also we override BasePermission class.

NOTE: If you need to test if a request is a read operation or a write operation, you should check the request method against the constant SAFE_METHODS, which is a tuple containing 'GET', 'OPTIONS' and 'HEAD'.

